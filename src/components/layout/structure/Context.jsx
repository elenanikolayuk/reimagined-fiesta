import Primer27 from "./Primer/Primer27/Primer27"


const Context = () => {
    return (
  <div>
<h1 className="title">Context (useContext)</h1>
<p>В React 18 был представлен новый и усовершенствованный API - Context. </p>
<p>Context предоставляет способ <b>передачи данных через дерево компонентов 
без явной передачи пропсов от родительских компонентов к дочерним</b>. 
Это особенно полезно, когда необходимо передать данные глубоко в иерархии компонентов, 
избегая "просачивания" пропсов через несколько промежуточных компонентов.</p>

<h2 className="title">Какую проблему решает context? (props drilling)</h2>
  <p>В React пропс-дриллинг (props drilling) - это паттерн, который возникает,
    когда компоненту нужно <b>передать данные через 
    несколько уровней других компонентов</b>. Он возникает, 
    когда компоненты передают свойства (props) другим компонентам,
    чтобы они могли использовать эти данные.</p>

<p>Пропс-дриллинг может стать проблемой, 
  когда данные нужно передавать через несколько уровней компонентов, и при этом каждый компонент 
  просто перенаправляет свойства следующему компоненту без реального использования этих свойств.</p>

<p>В этом примере значение <b className="redname"> value</b> передается через несколько компонентов, 
  хотя <b className="redname"> GrandParentComponent </b> и 
  <b className="redname"> ParentComponent </b> фактически не использует это значение. 
  Вместо этого оно просто передается через компоненты, чтобы достичь конечного компонента, 
  где оно может быть использовано.</p>

<p>Пропс-дриллинг может привести к избыточности и усложнению кода. 
  Он также делает компоненты <b>более зависимыми от их иерархии</b>, 
  что <b>может затруднить их переиспользование и модификацию</b>.</p>

<p>Чтобы <b>избежать проблемы</b> пропс-дриллинга, 
  в React можно использовать более продвинутые паттерны, 
  <b> такие как контекст (context)</b>, который позволяет 
  передавать данные глубже в иерархию компонентов 
  <b> без явного прокидывания </b> свойств через каждый уровень.</p>
  <p>Пропс-дриллинг может привести к избыточности и усложнению кода. 
    Он также делает компоненты <b>более зависимыми от их иерархии</b>, 
    что <b>может затруднить их переиспользование и модификацию</b>.</p>

<p>Чтобы <b>избежать проблемы</b> пропс-дриллинга, 
в React можно использовать более продвинутые паттерны, 
<b>такие как контекст (context)</b>, который позволяет передавать данные глубже в иерархию компонентов 
<b>без явного прокидывания</b> свойств через каждый уровень.</p>
  
<h2 className="title">Использование Context:</h2>

<p>Для работы с Context в React необходимо выполнить следующие шаги:</p>

<p><b>Шаг 1: Создание контекста</b></p>
<p>Сначала мы должны создать контекст с помощью функции <b className="redname"> createContext()  </b> из модуля react.</p>
<p>В этом примере создается новый контекст с помощью <b className="redname"> createContext() </b>
  и экспортируется для дальнейшнего использования.</p>
  
<p><b>Шаг 2: Предоставление значения контекста</b></p>
<p>Затем  нужно предоставить значение контекста внутри компонента-провайдера. 
  Компонент-провайдер <b>обертывает</b> дерево компонентов, <b>которым нужен доступ к контексту</b>.</p>

<p>В этом примере используется <b className="redname">MyContext.Provider</b> 
для предоставления значения контекста. 
Значение <b className="redname">value</b> будет <b>доступно всем дочерним компонентам</b>, 
которые подписаны на этот контекст.</p>

<p><b>Шаг 3: Использование хука useContext</b></p>
<p>Теперь можно использовать хук <b className="redname">useContext</b> внутри функционального компонента, 
  <b>чтобы получить доступ к значению контекста</b>.</p>

<p>Теперь можно использовать значение <b className="redname">value</b> внутри 
  компонента без необходимости использования <b className="redname">MyContext.Consumer</b> 
  (<b>про него поговорим дальше</b>).</p>
  
<p><b>Шаг 4: Подписка на контекст (еще один вариант)</b></p>
<p>Есть еще один вариант подписаться на контекст в компонентах, где нужны переданные значения. 
Для этого используется <b className="redname">MyContext.Consumer</b>.</p>

<p>В этом примере используется <b className="rename">MyContext.Consumer </b> 
для получения значения контекста и отображения его внутри компонента. 
Значение контекста будет доступно внутри функции-рендерера в виде аргумента.</p>

<p><b>Примечание:</b> Если ты используешь React Hooks, такие как <b className="redname">useContext</b>, 
ты можешь извлечь значение контекста с помощью хука <b className="redname"> useContext()</b>. 
Это упрощает работу с контекстом и уменьшает необходимость в использовании 
<b className="redname"> MyContext.Consumer</b>.</p>

<h3 className="title">Заключение:</h3>
<p>Context в React 18 предоставляет способ передачи данных через компоненты
 без использования пропсов. Он позволяет легко передавать данные во 
 всем дереве компонентов и упрощает управление состоянием и данными приложения.</p>

<p>Context является мощным инструментом, но его следует использовать с умом. 
Перегрузка контекстом всего приложения может привести <b>к усложнению и запутыванию кода</b>.
</p>

<p>Рекомендуется использовать контекст там, где он действительно необходим, например, 
для глобального состояния приложения или темизации.</p>

<Primer27 />







  </div>

    )
}
export { Context }  